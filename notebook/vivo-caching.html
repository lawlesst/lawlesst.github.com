<!DOCTYPE html>
<html>

<head>
  <title>Caching VIVO profiles with ETags and mod_cache</title>
  
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/static/styles.css">
  
</head>

<body>
  <div id="content">
    <header>
      <h1><a href="/">Ted Lawless</a>
        <h1>
    </header>
    

<h3>Caching VIVO profiles with ETags and mod_cache</h3>
<h5>03-25-13</h5>
<div id="post-contents">
  <blockquote>
  <p>Update - Caching VIVO pages with ETags was made part of the VIVO/Vitro core code in
  release 1.6. This solution is no longer necessary and the methods described here have been made part of the software. See the <a href="https://wiki.duraspace.org/display/VIVO/Use+HTTP+caching+to+improve+performance">project documentation</a> for information on how to set this up. Any questions can be sent to vivo-tech@googlegroups.com.</p>
</blockquote>

<hr />

<blockquote>
  <p>Update - 3/29/13 - since writing this, I learned about Solr's built in support for generating signatures of document contents.  Taking advantage of this feature of Solr simplifies the servlet filter code described below and addresses one of the limitations of the caching system described below.  See the updated <a href="https://github.com/Brown-University-Library/vivo/blob/etag/productMods/WEB-INF/pyfilter/EtagFilter.py">servlet filter code</a> and the <a href="http://lawlesst.github.com/notebook/solr-etags.html">Solr configuration</a>.  The remaining steps described still apply.</p>
</blockquote>

<p>This document describes a proof of concept for caching <a href="http://www.vivoweb.org/">VIVO</a> profiles with ETags and mod<em>cache.  The use of mod</em>cache and ETags described here could be applied to other web applications.</p>

<h3>The problem - page load time</h3>

<p>A recurring question in the <a href="http://www.vivoweb.org/">VIVO</a> implementation community is how sites can speed up the loading of profile pages.  As a VIVO implementation grows in size and tracks more and more scholarly activity, profile pages can be pulling in hundreds of relationships to render the page, which results in more data being retrieved from the underling <a href="http://jena.apache.org/documentation/rdf/index.html">Jena</a> <a href="http://jena.apache.org/documentation/sdb/index.html">SDB store</a> and longer page load times.  For example, a profile page for a faculty member with hundreds of publications, which isn't uncommon, can lead to multiple second page loads.</p>

<h3>The approach - ETags plus mod_cache</h3>

<p>An <a href="http://sourceforge.net/mailarchive/message.php?msg_id=29749479">email thread</a> on the implementation mailing list in August of 2012 concluded that using <a href="http://en.wikipedia.org/wiki/HTTP_ETag">HTTP ETags</a> to cache public pages could be the best route.</p>

<p>The caching system described below will consist of two main components:</p>

<ul>
<li><p>A simple servlet filter, called <a href="https://github.com/Brown-University-Library/vivo/blob/etag/productMods/WEB-INF/pyfilter/EtagFilter.py">EtagFilter.py</a>, that validates a client's ETag or generates a new ETag.</p></li>
<li><p>Apache <a href="http://httpd.apache.org/docs/2.2/caching.html">mod_cache</a> as a reverse-proxy.</p></li>
</ul>

<p>This caching configuration will only be utilized for users that are not logged in.  Requests initiated by logged in users will be generated dynamically as normal.</p>

<h4>Generating the ETag</h4>

<p>The <a href="http://en.wikipedia.org/wiki/HTTP_ETag">ETag</a> is generated by looking up the requested individual resource in the VIVO Solr index and creating a hash of the contents of specified fields.  This approach is laid out in the <a href="http://sourceforge.net/mailarchive/message.php?msg_id=29749479">email thread</a> discussing possible implementations of caching in VIVO.  This approach assumes that the Solr document for a given individual is the most up-to-date representation of the contents, which given VIVO's near real-time indexing of content changes this seems to be an OK assumption.</p>

<p>The incoming request header is inspected for an "If-None-Match" field which contains the ETag for the version of the page that the client last requested.  If this ETag matches the ETag generated for the current state of the individual (e.g. no updates have been made since the client last fetched the page), then a HTTP response is immediately generated with a 304 Not Modified status code and the request is not processed further.  This tells the client to use the cached version of the page.</p>

<div class="codehilite"><pre><span></span><code>    <span class="k">def</span> <span class="nf">doFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">chain</span><span class="p">):</span>
        <span class="c1">#Don&#39;t generate etags for logged in users.</span>
        <span class="n">login_status</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="s1">&#39;loginStatus&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">login_status</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">login_status</span><span class="o">.</span><span class="n">isLoggedIn</span><span class="p">()):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;User is logged in.  Caching disabled.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">url_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">getRequestURL</span><span class="p">())</span>
            <span class="n">individual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_url_individual</span><span class="p">(</span><span class="n">url_string</span><span class="p">)</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_solr_doc</span><span class="p">(</span><span class="n">individual</span><span class="p">)</span>
            <span class="n">etag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_etag</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">etag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">non_match</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="s2">&quot;If-None-Match&quot;</span><span class="p">)</span>
                <span class="c1">#If we have an incoming matching etag return 304.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">non_match</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">non_match</span> <span class="o">==</span> <span class="n">etag</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Etag matched.&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">sendError</span><span class="p">(</span><span class="n">HttpservletResponse</span><span class="o">.</span><span class="n">SC_NOT_MODIFIED</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Etag did not match.&#39;</span><span class="p">)</span>
                    <span class="c1">#Else set the new etag.</span>
                    <span class="n">response</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="s2">&quot;ETag&quot;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">etag</span><span class="p">)</span>
        <span class="n">chain</span><span class="o">.</span><span class="n">doFilter</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
</code></pre></div>

<p>The full source for the <a href="https://github.com/Brown-University-Library/vivo/blob/etag/productMods/WEB-INF/pyfilter/EtagFilter.py">EtagFilter.py</a> and changes to the VIVO <a href="https://github.com/Brown-University-Library/vivo/blob/etag/productMods/WEB-INF/web.xml#L84">web.xml</a> are on Github.</p>

<p>Since modern browsers support ETags, the above servlet filter will provide caching on a client by client basis.  This means that if User A accesses a VIVO profile at 10am and then returns to view the profile at 12pm, the 12pm request will be served from the cache, provided the profile wasn't updated between 10 and 12.  This will be a nice benefit for regular users of the site but we can do better by using an HTTP accelerator, or reverse proxy.</p>

<h3>Use mod_cache as a reverse proxy</h3>

<p>Apache <a href="http://httpd.apache.org/docs/2.2/caching.html">mod_cache</a> is an Apache module that stores on disk copies of content and provides methods for retrieving or expiring pages stored within it, serving as a built-in <a href="http://en.wikipedia.org/wiki/Reverse_proxy">reverse proxy</a>.</p>

<p>By using mod<em>cache, the VIVO application is essentially serving one client (mod</em>cache) for non logged in users which increases the likelihood that a profile page will be available in the cache.  Building on our example above, if User A views a VIVO profile at 10am the profile is generated and stored in mod<em>cache.  When User B views the profile at 11am, mod</em>cache issues a conditional request with the ETag.  The servlet filter recognizes the conditional request, validates the ETag (assuming content hasn't updated) and issues the 304 Not Modified response which tells mod_cache to serve the cached copy of the profile.  This process, while rather wordy, happens much faster than generating a new profile since no SPARQL queries have to be generated against the SDB store.</p>

<p>Below is a sample mod<em>cache configuration.  On a typical RedHat server this would be placed at /etc/httpd/conf.d/mod</em>cache.conf.</p>

<pre><code>&lt;IfModule mod_cache.c&gt;
     CacheRoot /var/cache/apache2
     CacheEnable disk /display
     CacheEnable disk /individual
     CacheIgnoreNoLastMod On
     CacheDefaultExpire 5
     CacheMaxExpire 5
     CacheIgnoreHeaders Set-Cookie
&lt;/IfModule&gt;

</code></pre>

<p>A key point in this configuration is described in the <a href="http://httpd.apache.org/docs/2.2/caching.html#overview">mod<em>cache documentation</a>, "When content expires from the cache and is re-requested from the backend or content provider, rather than pass on the original request, Apache will use a conditional request instead."  If a page hasn't expired within mod</em>cache, the request will be served directly from the cache and not reach the VIVO application at all.  This might be desirable in implementations where data is updated at regular intervals.  But in implementations where self-editing of profiles will be supported, it will be necessary to frequently validate the ETag to make sure users are seeing the freshest copy of the data.  To have mod_cache generate conditional requests often, set the default expire and max expire values to something quite low - five seconds in the example above.  The page will still be served from the cache if the content hasn't changed (since the servlet filter will respond with a 304 Not Modified), but the conditional request will allow the servlet filter to verify the state of the profile before serving the cached copy.</p>

<h3>Summary and limitations</h3>

<p>In our non-public instances of VIVO, the above configuration and code do significantly improve page rendering times for VIVO profiles.  If a profile page is in the cache, the rendering time drops to the second range that users expect.  We plan to further test this filter with <a href="http://jmeter.apache.org/">JMeter</a> to see how it performs while serving concurrent requests.</p>

<p>There are also several limitations to consider:</p>

<ul>
<li>each page load will generate a (extra?) Solr request for each page load to validate and create the ETag.</li>
<li><s>each page load generates the ETag; it's not stored.  This could be addressed, as mentioned in the above email thread, by storing the ETag in the Solr document so that it could be retrieved each time rather than generated.</s> This concern has been addressed by <a href="http://lawlesst.github.com/notebook/solr-etags.html">configuring Solr</a> to generate and store document signatures.</li>
<li>no improvement to page load times for logged in users.  This may or may not be a problem depending on how the VIVO instance is used.</li>
<li>the current servlet filter is written in Jython.  It would be best to write this in Java to not introduce another VIVO dependency.</li>
</ul>

<h3>Further resources</h3>

<ul>
<li><a href="http://www.softslate.com/blog/2011/07/apache-modcache-in-real-world.html">Apache mod<em>cache in the Real World</a> was helpful in understanding how mod</em>cache works.</li>
<li>The Jython <a href="http://www.jython.org/jythonbook/en/1.0/SimpleWebApps.html">servlet</a> and <a href="http://www.jython.org/javadoc/org/python/util/PyFilter.html">PyFilter</a> documentation.</li>
<li><a href="http://start.sethanil.com/ot/10">Making Life Easier for a Programmer Servlets That Use Jython</a> helps piece together the Jython documentation.</li>
</ul>

</div>



    <footer>
      <a href="/">Ted Lawless</a>, 2022
      <ul>
        <li>lawlesst at gmail</li>
        <li><a href="https://github.com/lawlesst">Github</a></li>
        <li><a href="https://www.linkedin.com/in/ted-lawless-bb30b65/">LinkedIn</a></li>
        <li><a href="https://twitter.com/tedlawless">Twitter</a></li>
    </footer>
  </div>

  

</body>

</html>